namespace codingame.heat.detector
{
	using System;
	using System.Collections.Generic;

	public class Building
	{
		private readonly Func<string> _readLine;
		private readonly Action<object> _writeLine;
		private readonly int _width;
		private readonly int _height;
		private readonly List<Window> _windowsHistory = new List<Window>();

		public Building(Func<string> readLine, Action<object> writeLine)
		{
			_readLine = readLine;
			_writeLine = writeLine;
			var inputs = _readLine().Split(' ');
			_width = int.Parse(inputs[0]); // width of the building.
			_height = int.Parse(inputs[1]); // height of the building.
			var N = int.Parse(_readLine()); // maximum number of turns before game over.
			_windowsHistory.Add(new Window(_readLine()));
		}

		public void Run()
		{
			// game loop
			while (true)
			{
				string bombDir;
				try
				{
					bombDir = _readLine();
				}
				catch (ArgumentException)
				{
					break;
				}

				var bombDirection = (Direction)Enum.Parse(typeof(Direction), bombDir);
				_writeLine(PredictJump(bombDirection)); // the location of the next window Batman should jump to.
			}
		}

		private bool PredictJump(Direction bombDirection)
		{
			throw new NotImplementedException();
		}
	}
}

namespace codingame.heat.detector
{
	public enum Direction
	{
		U,
		UR,
		R,
		DR,
		D,
		DL,
		L,
		UL
	}
}

namespace codingame.heat.detector
{
	using System;

	/**
     * Auto-generated code below aims at helping you parse
     * the standard input according to the problem statement.
     **/
	public class Program
	{
		public static void Main(string[] args)
		{
			var building = new Building(Console.ReadLine, Console.WriteLine);

			building.Run();
		}
	}
}


namespace codingame.heat.detector
{
	public class Window
	{
		public Window(string readLine)
		{
			var inputs = readLine.Split(' ');
			X = int.Parse(inputs[0]);
			Y = int.Parse(inputs[1]);
		}

		public int Y { get; }

		public int X { get; }

		public override string ToString()
		{
			return X + " " + Y;
		}

		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj))
			{
				return false;
			}

			if (ReferenceEquals(this, obj))
			{
				return true;
			}

			var other = obj as Window;
			return other != null && Equals(other);
		}

		private bool Equals(Window other)
		{
			return X == other.X && Y == other.Y;
		}

		public override int GetHashCode()
		{
			return ToString().GetHashCode();
		}
	}
}







